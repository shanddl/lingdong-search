// 外观设置面板管理（优化版）

/**
 * 滑块配置
 * 统一管理所有滑块的配置信息
 */
const SLIDER_CONFIG = {
    // 壁纸背景适配滑块
    wallpaper: [
        {
            id: 'overlay-opacity-slider',
            valueId: 'effects-val-overlay',
            cssVar: '--overlay-opacity',
            storageKey: 'wallpaperEffects.overlayOpacity',
            format: (v) => `${v}%`,
            toCSS: (v) => v / 100,
        },
        {
            id: 'search-bg-opacity-slider',
            valueId: 'effects-val-search-bg',
            cssVar: '--search-bg-opacity',
            storageKey: 'wallpaperEffects.searchBgOpacity',
            format: (v) => `${v}%`,
            toCSS: (v) => v / 100,
            applyFn: (value) => {
                // 动态调整搜索框文字和按钮颜色
                // 当背景不透明度为0时，使用白色；不透明度增加时，逐渐变为深色
                const opacity = value / 100;
                
                // 计算文字颜色：从白色渐变到深灰色
                const textLightness = Math.max(240 - opacity * 190, 50); // 240 -> 50
                const textColor = `rgba(${textLightness}, ${textLightness}, ${textLightness + 10}, 0.9)`;
                
                // 计算按钮颜色：从白色渐变到深灰色
                const btnLightness = Math.max(235 - opacity * 175, 60); // 235 -> 60
                const btnColor = `rgba(${btnLightness}, ${btnLightness}, ${btnLightness + 10}, 0.8)`;
                
                // 计算时钟颜色：从浅金色到深金色
                const clockBrightness = Math.max(226 - opacity * 26, 200); // 226 -> 200
                const clockColor = `rgb(${clockBrightness}, ${Math.floor(clockBrightness * 0.69)}, ${Math.floor(clockBrightness * 0.36)})`;
                
                // 应用颜色
                document.documentElement.style.setProperty('--search-text-color', textColor);
                document.documentElement.style.setProperty('--search-btn-color', btnColor);
                document.documentElement.style.setProperty('--search-clock-color', clockColor);
            },
        },
        {
            id: 'search-blur-slider',
            valueId: 'effects-val-search-blur',
            cssVar: '--search-blur',
            storageKey: 'wallpaperEffects.searchBlur',
            format: (v) => `${v}px`,
            toCSS: (v) => `${v}px`,
        },
        {
            id: 'search-border-opacity-slider',
            valueId: 'effects-val-search-border',
            cssVar: '--search-border-opacity',
            storageKey: 'wallpaperEffects.searchBorderOpacity',
            format: (v) => `${v}%`,
            toCSS: (v) => v / 100,
        },
        {
            id: 'icon-bg-opacity-slider',
            valueId: 'effects-val-icon-bg',
            cssVar: '--icon-bg-opacity',
            storageKey: 'wallpaperEffects.iconBgOpacity',
            format: (v) => `${v}%`,
            toCSS: (v) => v / 100,
        },
        {
            id: 'icon-blur-slider',
            valueId: 'effects-val-icon-blur',
            cssVar: '--icon-blur',
            storageKey: 'wallpaperEffects.iconBlur',
            format: (v) => `${v}px`,
            toCSS: (v) => `${v}px`,
        },
        {
            id: 'text-shadow-opacity-slider',
            valueId: 'effects-val-text-shadow',
            cssVar: '--text-shadow-opacity',
            storageKey: 'wallpaperEffects.textShadowOpacity',
            format: (v) => `${v}%`,
            toCSS: (v) => v / 100,
        },
    ],
    
    // 搜索框滑块
    searchbox: [
        {
            id: 'position-slider',
            valueId: 'effects-val-pos',
            storageKey: 'searchboxTop',
            format: (v) => `${v}%`,
            applyFn: (value) => window.core?.applySearchboxPosition(value),
        },
        {
            id: 'width-slider',
            valueId: 'effects-val-width',
            storageKey: 'searchboxWidth',
            format: (v) => `${v}px`,
            applyFn: (value) => window.core?.applySearchboxWidth(value),
        },
        {
            id: 'scope-width-slider',
            valueId: 'effects-val-scope',
            storageKey: 'scopeMenuWidth',
            format: (v) => `${v}px`,
            applyFn: (value) => window.core?.applyScopeMenuWidth(value),
        },
    ],
    
    // 图标滑块
    navigation: [
        {
            id: 'nav-item-size-slider',
            valueId: 'effects-val-size',
            storageKey: 'navigationItemSize',
            format: (v) => `${v}px`,
            applyFn: (value, state) => {
                const gap = state?.userData?.navigationGridGap;
                window.navigationModule?.utils?.applyAppearanceSettings(value, gap);
            },
        },
        {
            id: 'nav-grid-gap-slider',
            valueId: 'effects-val-gap',
            storageKey: 'navigationGridGap',
            format: (v) => `${v}px`,
            applyFn: (value, state) => {
                const size = state?.userData?.navigationItemSize;
                window.navigationModule?.utils?.applyAppearanceSettings(size, value);
            },
        },
        {
            id: 'nav-min-width-slider',
            valueId: 'effects-val-min',
            storageKey: 'navigationSettings.minWidth',
            format: (v) => `${v}px`,
            applyFn: (value) => {
                const navGrid = document.getElementById('navigation-grid');
                navGrid?.style.setProperty('--nav-item-min-width', `${value}px`);
            },
        },
        {
            id: 'dock-scale-slider',
            valueId: 'effects-val-dock',
            cssVar: '--dock-scale',
            storageKey: 'dockSettings.scale',
            format: (v) => `${v.toFixed(1)}x`,
            toCSS: (v) => v,
        },
    ],
};

/**
 * 外观设置面板类
 */
class EffectsPanel {
    constructor() {
        this.panel = document.getElementById('effectsSettingsPanel');
        this.overlay = document.getElementById('effectsPanelOverlay');
        this.settingsLoaded = false;
        
        this.init();
    }
    
    init() {
        this.bindPanelEvents();
        this.bindAccordion();
        this.bindSliders();
        this.bindButtons();
        this.applyCriticalSettings();
        // 注意：applySavedCSSVariables 在 core.applyAllSettings 中调用（数据加载完成后）
        
        // ESC键关闭
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && this.panel.classList.contains('visible')) {
                this.closePanel();
            }
        });
    }
    
    openPanel() {
        if (!this.settingsLoaded) {
            this.loadSliderValues();
            this.loadPanelTheme();
            this.settingsLoaded = true;
        }
        
        this.panel.classList.add('visible');
        this.overlay.classList.add('visible');
        document.body.style.overflow = 'hidden';
    }
    
    loadPanelTheme() {
        // 从state中读取保存的主题
        const savedTheme = window.state?.userData?.panelSettings?.theme || 'light';
        
        // 应用主题
        if (savedTheme === 'dark') {
            this.panel.classList.add('dark-theme');
        } else {
            this.panel.classList.remove('dark-theme');
        }
        
        // 更新按钮状态
        document.querySelectorAll('[data-action="set-panel-theme"]').forEach(btn => {
            if (btn.dataset.theme === savedTheme) {
                btn.classList.add('active');
            } else {
                btn.classList.remove('active');
            }
        });
    }
    
    closePanel() {
        this.panel.classList.remove('visible');
        this.overlay.classList.remove('visible');
        document.body.style.overflow = '';
    }
    
    bindPanelEvents() {
        // 只通过遮罩层关闭
        this.overlay.addEventListener('click', () => this.closePanel());
    }
    
    /**
     * 绑定折叠菜单事件（算盘珠效果）
     */
    bindAccordion() {
        const accordionItems = this.panel.querySelectorAll('.effects-accordion-item');
        
        accordionItems.forEach(item => {
            const header = item.querySelector('.effects-accordion-header');
            
            header.addEventListener('click', () => {
                const isExpanded = item.classList.contains('expanded');
                
                if (isExpanded) {
                    // 如果已展开，则收起
                    item.classList.remove('expanded');
                } else {
                    // 关闭所有其他项
                    accordionItems.forEach(otherItem => {
                        otherItem.classList.remove('expanded');
                    });
                    
                    // 展开当前项
                    item.classList.add('expanded');
                }
            });
        });
    }
    
    /**
     * 绑定所有滑块（统一处理）
     */
    bindSliders() {
        const { state, core } = window;
        
        if (!state || !core) {
            console.error('❌ window.state/core 未定义');
            return;
        }
        
        // 合并所有滑块配置
        const allSliders = [
            ...SLIDER_CONFIG.wallpaper,
            ...SLIDER_CONFIG.searchbox,
            ...SLIDER_CONFIG.navigation,
        ];
        
        allSliders.forEach(config => {
            this.bindSlider(config);
        });
    }
    
    /**
     * 绑定单个滑块（通用方法）
     */
    bindSlider(config) {
        const slider = document.getElementById(config.id);
        if (!slider) return;
        
        const valueDisplay = document.getElementById(config.valueId);
        
        // input事件：实时更新显示和CSS
        slider.addEventListener('input', (e) => {
            const value = config.format ? parseFloat(e.target.value) : e.target.value;
            
            // 更新显示文字
            if (valueDisplay) {
                valueDisplay.textContent = config.format(value);
            }
            
            // 应用CSS变量
            if (config.cssVar) {
                document.documentElement.style.setProperty(
                    config.cssVar, 
                    config.toCSS ? config.toCSS(value) : value
                );
            }
            
            // 调用自定义应用函数
            if (config.applyFn) {
                config.applyFn(value, window.state);
            }
        });
        
        // change事件：保存到state
        slider.addEventListener('change', (e) => {
            const value = config.format ? parseFloat(e.target.value) : e.target.value;
            this.saveSliderValue(config.storageKey, value);
        });
    }
    
    /**
     * 保存滑块值到state（支持嵌套路径）
     */
    saveSliderValue(path, value) {
        const { state, core } = window;
        if (!state || !core) return;
        
        const keys = path.split('.');
        let obj = state.userData;
        
        // 遍历路径，创建不存在的对象
        for (let i = 0; i < keys.length - 1; i++) {
            if (!obj[keys[i]]) obj[keys[i]] = {};
            obj = obj[keys[i]];
        }
        
        // 设置最终值
        obj[keys[keys.length - 1]] = value;
        core.saveUserData();
    }
    
    /**
     * 从state读取滑块值（支持嵌套路径）
     */
    getSliderValue(path) {
        const { state } = window;
        if (!state?.userData) return undefined;
        
        const keys = path.split('.');
        let value = state.userData;
        
        for (const key of keys) {
            if (value === undefined) return undefined;
            value = value[key];
        }
        
        return value;
    }
    
    /**
     * 绑定所有按钮
     */
    bindButtons() {
        // 绑定所有快速操作按钮
        const quickActionBtns = this.panel.querySelectorAll('.effects-btn[data-action]');
        quickActionBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                const action = btn.dataset.action;
                const group = btn.parentElement;
                
                // 切换激活状态
                group.querySelectorAll('.effects-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                
                // 执行对应操作
                this.handleButtonAction(action, btn.dataset);
            });
        });
        
        // 绑定头部的面板位置按钮
        const positionBtns = this.panel.querySelectorAll('.effects-position-btn[data-action]');
        positionBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                const action = btn.dataset.action;
                const group = btn.parentElement;
                
                // 切换激活状态
                group.querySelectorAll('.effects-position-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                
                // 执行对应操作
                this.handleButtonAction(action, btn.dataset);
            });
        });
    }
    
    /**
     * 处理按钮操作
     */
    handleButtonAction(action, data) {
        switch(action) {
            case 'set-panel-position':
                this.setPanelPosition(data.position);
                break;
            case 'set-nav-alignment':
                this.setNavAlignment(data.align);
                break;
            case 'set-nav-shape':
                this.setNavShape(data.shape);
                break;
        }
    }
    
    /**
     * 设置面板位置（左/右）
     */
    setPanelPosition(position) {
        if (position === 'left') {
            this.panel.classList.add('panel-left');
        } else {
            this.panel.classList.remove('panel-left');
        }
        localStorage.setItem('panel-position', position);
    }
    
    /**
     * 设置导航对齐
     */
    setNavAlignment(align) {
        const navGrid = document.getElementById('navigation-grid');
        if (!navGrid) return;
        
        const alignmentMap = {
            left: { marginLeft: '0', marginRight: 'auto' },
            right: { marginLeft: 'auto', marginRight: '0' },
            center: { marginLeft: 'auto', marginRight: 'auto' },
        };
        
        const style = alignmentMap[align];
        if (style) {
            Object.assign(navGrid.style, style);
            localStorage.setItem('nav-alignment', align);
        }
    }
    
    /**
     * 设置导航形状
     */
    setNavShape(shape) {
        document.body.classList.toggle('shape-h-capsule', shape === 'h-capsule');
        localStorage.setItem('nav-shape', shape);
    }
    
    /**
     * 应用关键样式（页面加载时立即执行）
     */
    applyCriticalSettings() {
        try {
            const panelPosition = localStorage.getItem('panel-position');
            const navAlign = localStorage.getItem('nav-alignment');
            const navShape = localStorage.getItem('nav-shape');
            
            if (panelPosition) this.setPanelPosition(panelPosition);
            if (navAlign) this.setNavAlignment(navAlign);
            if (navShape) this.setNavShape(navShape);
        } catch (error) {
            console.error('应用关键样式失败:', error);
        }
    }
    
    /**
     * 应用保存的CSS变量（页面加载时立即执行，不更新UI）
     */
    applySavedCSSVariables() {
        try {
            const { state } = window;
            if (!state?.userData) return;
            
            // 合并所有滑块配置
            const allSliders = [
                ...SLIDER_CONFIG.wallpaper,
                ...SLIDER_CONFIG.searchbox,
                ...SLIDER_CONFIG.navigation,
            ];
            
            // 只应用有CSS变量或applyFn的滑块
            allSliders.forEach(config => {
                const value = this.getSliderValue(config.storageKey);
                
                // 如果没有保存的值，跳过（使用CSS默认值）
                if (value === undefined) return;
                
                // 应用CSS变量
                if (config.cssVar) {
                    document.documentElement.style.setProperty(
                        config.cssVar, 
                        config.toCSS ? config.toCSS(value) : value
                    );
                }
                
                // 调用自定义应用函数
                if (config.applyFn) {
                    config.applyFn(value, state);
                }
            });
        } catch (error) {
            console.error('应用保存的CSS变量失败:', error);
        }
    }
    
    /**
     * 加载滑块值和按钮状态（延迟到打开面板时）
     */
    loadSliderValues() {
        try {
            // 更新按钮状态
            this.updateButtonStates();
            
            // 更新所有滑块值
            const allSliders = [
                ...SLIDER_CONFIG.wallpaper,
                ...SLIDER_CONFIG.searchbox,
                ...SLIDER_CONFIG.navigation,
            ];
            
            allSliders.forEach(config => {
                this.loadSliderValue(config);
            });
        } catch (error) {
            console.error('加载滑块值失败:', error);
        }
    }
    
    /**
     * 加载单个滑块值（通用方法）
     */
    loadSliderValue(config) {
        const slider = document.getElementById(config.id);
        const valueDisplay = document.getElementById(config.valueId);
        
        if (!slider) return;
        
        const value = this.getSliderValue(config.storageKey);
        if (value === undefined) return;
        
        // 设置滑块值
        slider.value = value;
        
        // 更新显示文字
        if (valueDisplay && config.format) {
            valueDisplay.textContent = config.format(value);
        }
        
        // 应用CSS变量
        if (config.cssVar) {
            document.documentElement.style.setProperty(
                config.cssVar, 
                config.toCSS ? config.toCSS(value) : value
            );
        }
        
        // 调用自定义应用函数
        if (config.applyFn) {
            config.applyFn(value, window.state);
        }
    }
    
    /**
     * 更新按钮状态
     */
    updateButtonStates() {
        // 面板位置按钮（头部）
        const panelPosition = localStorage.getItem('panel-position') || 'right';
        const posBtn = this.panel.querySelector(`.effects-position-btn[data-position="${panelPosition}"]`);
        if (posBtn) {
            posBtn.parentElement.querySelectorAll('.effects-position-btn').forEach(b => 
                b.classList.remove('active')
            );
            posBtn.classList.add('active');
        }
        
        // 导航对齐按钮
        const navAlign = localStorage.getItem('nav-alignment') || 'center';
        this.updateButtonState(`[data-align="${navAlign}"]`, '.effects-btn');
        
        // 导航形状按钮
        const navShape = localStorage.getItem('nav-shape') || 'square';
        this.updateButtonState(`[data-shape="${navShape}"]`, '.effects-btn');
    }
    
    /**
     * 更新按钮激活状态
     */
    updateButtonState(selector, buttonClass = '.effects-btn') {
        const btn = this.panel.querySelector(selector);
        if (btn) {
            btn.parentElement.querySelectorAll(buttonClass).forEach(b => 
                b.classList.remove('active')
            );
            btn.classList.add('active');
        }
    }
}

// 导出函数
let effectsPanelInstance = null;

export function initEffectsPanel() {
    if (!effectsPanelInstance) {
        effectsPanelInstance = new EffectsPanel();
    }
    return effectsPanelInstance;
}

/**
 * 打开效果面板（懒初始化 - 首次调用时才创建实例）
 */
export function openEffectsPanel() {
    // 懒初始化：如果实例不存在，先创建
    if (!effectsPanelInstance) {
        console.log('[LazyInit] Effects panel initialized on first open');
        initEffectsPanel();
    }
    effectsPanelInstance.openPanel();
}

/**
 * 应用保存的CSS变量（从外部调用，在数据加载完成后）
 * 懒初始化：如果实例不存在，先创建
 */
export function applyEffectsCSSVariables() {
    // 懒初始化：如果实例不存在，先创建
    if (!effectsPanelInstance) {
        console.log('[LazyInit] Effects panel initialized for CSS variables');
        initEffectsPanel();
    }
    effectsPanelInstance.applySavedCSSVariables();
}
